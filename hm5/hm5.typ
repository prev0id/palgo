#set page(
  paper: "a4",
  numbering: "1",
  number-align: right,
  header: [
    #smallcaps[Деев Семен Алексеевич]
    #h(1fr) ВШЭ - БКНАД222
  ],
)

#set par(justify: true)

#show raw.where(block: true): code => {
  show raw.line: line => {
    text(fill: gray)[#line.number]
    h(1em)
    line.body
  }
  code
}

#show raw.where(block: true): block.with(
  fill: luma(250),
  inset: 10pt,
  radius: 4pt,
)

#show link: set text(fill: blue, weight: 700)
#show link: underline

#let line-block = rect.with(fill: luma(240), stroke: (left: 0.25em))

Извиняюсь за отсутствие кода, нет времени чтобы это нормально закодить

= Задание 1
#line-block[
  Дана правильная скобочная последовательность. Нужно найти у каждой скобки соответствующую пару за $O(n) "work"$ и $O(sqrt(n) "polylog" n) "span"$.
]

+ Разбиваем строку на $sqrt(n)$ блоков
  - Параллельно на каждом блоке $k$ вычисляем пары, внутри блока алгоритм последовательный
  - Сохраняем индексы скобок без пар в массивы $"open"[k]$, $"close"[k]$
  $ "work" = O(n), "scan" = O(sqrt(n) dot log sqrt(n)) = O(sqrt(n) dot log n) $
+ Дальше строим бинарное дерево
  - В листьях храним указатели на массивы $"open"[k]$, $"close"[k]$
  - В вершинах храним количество незаматченных открывающихся и закрывающихся скобок $("len"("open"), "len"("close"))$,
    а также число пар, которые образуются $"match" = min("len"("left_child.open"),"len"("right_child.close"))$
  $ "work" = O(n), "scan" = O(log sqrt(n)) = O(log n) $
+ Получается по дереву из п.2 мы можем за $log sqrt(n)$ найти пару для каждой оставшейся скобки
  - Для $"open"[i][j]$ (j-я открывающаяся скобка из i-го блока).
      - Поднимаемся по дереву вверх, пока сумма $"match"$ пройденных вершин не превышает $"len"("open"[i]) - j$
      - Cпускаемся по правому поддереву найденной вершины, ищя закрывающуюся скобку с нужным индексом, мы можем это сделать так как каждая вершина хранит количество скобок без пар
  - в худшем случае поиск n скобок, за $log sqrt(n)$ каждая в `ParallelFor`, займет:
  $ "work" = O(n), "scan" = O(log n dot log sqrt(n)) = O(log^2 n) $


= Задание 2
#line-block[
  Дано выражение, где каждая операция обрамлена скобками, а операнды - цифры. Постройте дерево вычислений за $O(n) "work"$ и $O(sqrt(n) "polylog" n) "span"$.
]

Напишу идею, времени довести ее до ума нет :(

+ Ищeм пары для скобок по алгоритму из 1 задания
+ Глубина вложенности для каждого символа
  - Сопоставляем `(` - +1, `)` - -1, остальные символы - 0
  - Делаем scan - получаем глубину вложенности
+ Зная глубину вложенности мы можем для каждой скобки определить соответсвтюущий ей оператор, и, наоборот, для каждого оператора мы можем найти соответствующие скобки
+ Разбиваем строку на $sqrt(n)$ блоков
  - Параллельно на обрабатываем блоки, внутри блока алгоритм последовательный
  - В блоке строим поддеревья, цифры в листья, операторы в вершины
+ Слияние блоков
  - Кажется, зная индексы соответствующих скобок, операторов и операндов можем параллельно сливать соседние блоки и соединять построенные в них поддеревья, уменьшая каждый раз количество блоков в 2 раза
